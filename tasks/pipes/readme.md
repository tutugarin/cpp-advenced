# Pipes

В Unix есть возможность объединять программы в цепочки.

Например, в цепочке `cat file | uniq | wc` на вход программе `uniq` будет
подан вывод команды `cat`. В свою очередь, вывод `uniq` будет подан на вход команде `wc`.

Этот подход можно адаптировать и для C++: сравните императивную версию

```cpp
auto file = get_file(file_name);
auto filtered = unique(file);
auto count = count(filtered);
```

с той, которую предлагается реализовать вам:

```cpp
auto pipeline = Pipeline()
    | get_file
    | unique
    | count;

pipeline(file_name);
```

У предлагаемого решения есть несколько преимуществ по сравнению с императивной версией:

1. Отсутствие изменяемых состояний (а значит, компилятор сможет лучше соптимизировать цепочку вызовов).
2. Удобство компоновки. Представим, что в примере выше результат нужно передать на вход другим трем функциям.

К существующей цепочке можно добавлять новые элементы, например,

```cpp
auto count_and_print = pipeline | print;
auto count_and_negate = pipeline | negate;
```

3. Отсутствие необходимости перепечатывать аргументы для функций в цепочке.

## pipes/basic

Реализуйте возможность комбинировать функторы в цепочки через `operator|`. В начале любой цепочки будет
стоять `Pipeline()`. К существующим цепочкам можно добавлять новые элементы.
Функторы нужно копировать.

Вспомните про [https://en.cppreference.com/w/cpp/types/decay](`std::decay_t`).

## pipes/rvalue

Добавьте корректную обработку rvalue для цепочек, чтобы использовать конструкторы перемещения там,
где это возможно.

При реализации этого пункта вы, скорее всего, столкнетесь с дублированием кода.
К сожалению, в С++20 этого не избежать, а вот в C++23 проблему решат с
помощью языковой возможности
[https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r6.html](deducing this).

## pipes/mutable

Поддержите в цепочках функторы с неконстантным `operator()` (в частности, mutable лямбды).
Обратите внимание, как использование внешнего/разделяемого состояния ломает семантику копирования
цепочек (тест "unexpected copy semantics").

## Мысленный эксперимент: noexcept

В C++ есть возможность указывать, при каких входных аргументах та или иная функция не кидает исключений --
[https://en.cppreference.com/w/cpp/language/noexcept_spec](`noexcept(expr)`).
Представьте, cколько кода нужно добавить, чтобы поддержать `noexcept(expr)` для цепочек.
Условием выполнения эксперимента является желание больше никогда не писать на C++.

Бонус: на той же странице документации можно увидеть, как некоторые языковые особенности добавляются
в стандарт уже устаревшими (ecли верить cppreference).
