# JPEG Decoder

<img src="tests/bad_quality.jpg" alt="harold" width="600"/>

В этом домашнем задании вам предстоит реализовать декодер JPEG. Подробности будут рассказаны на семинарах.

## Установка библиотек

### Ubuntu

```sh
sudo apt install libjpeg-dev libpng-dev libfftw3-dev
```

### OS X

```sh
brew install libjpeg libpng fftw
```

## Оценивание

Задача разделена на 6 подзадач.

| Название | Стоимость |
|----------|-----------|
| [huffman](#huffman) | 2 балла |
| [fftw](#fftw) | 1.5 балла |
| [baseline](#baseline) | 2.5 балла|
| [faster](#faster) | 1.5 балл |
| [progressive](#progressive) | 2.5 балла |
| [fuzz](#jpeg-fuzz) | см. ниже |

* Fuzzing-тестирование на сервере будет запущено после дедлайна для всех решений. В случае, если сданы подзадачи *huffman* и *fftw*, прохождение этих тестов прибавляет **1 балл**. Если также сданы подзадачи *baseline* и *faster*, то прибавляются **еще 1.5 балла**. Таким образом, вы можете получить **10 баллов** без подзадачи *progressive*. 


* В этой задаче есть *пасхалка*. Если вы её найдёте, напишите семинаристу или лектору в личные сообщения. Первые 10 человек, которые смогут объяснить, что и как они нашли, получат бонусный балл.

## Что надо сделать

### <a id="huffman"></a> Huffman

> Суть: реализовать декодирование с помощью дерева Хаффмана

Смотрите секцию [The actual DHT in the JPEG file](https://www.impulseadventure.com/photo/jpeg-huffman-coding.html) и слайды.

На вход классу подается вектор `code_lengths`, где `code_lengths[i]` - количество листьев на глубине `i + 1` (если `root` имеет глубину 0). Также на вход подаются значения, записанные в листьях этого дерева в порядке обхода "сначала левое поддерево, потом правое".

Также имплементируйте метод `Move`, реализующий интерфейс движения по ребру с заданным значением `bit` дерева из текущей вершины. Если конечная вершина ребра является листом, значение в листе нужно записать в переданную переменную и вернуть `true`. Текущая вершина в дереве при этом сбрасывается, и при следующем вызове метода начальной вершиной будет не лист дерева.

### <a id="fftw"></a> FFTW

> Cуть: реализовать IDCT (обратное дискретное косинусное преобразование) при помощи FFTW

На вход подаются двумерные матрицы 8x8 в одномерном виде (чтобы было быстрее).

Поищите в [документации](https://www.fftw.org/index.html) по ключевым словам IDCT/DCT:
* какие функции вам надо использовать
* с какими параметрами (спойлер: там должно быть что-то про двумерность)

Переиспользуйте план между вызовами при реализации следующего пункта. Не забудьте удалить план, когда он больше не нужен. Для удаления есть специальная функция в библиотеке.

### <a id="baseline"></a> Baseline

> Суть: ~~нарисуйте сову~~ используйте предыдущие две подзадачи, чтобы реализовать декодер, умеющий читать файлы.

Храните информацию о том, сколько байт вы просканировали, чтобы понимать текущую позицию в файле и общий прогресс по JPEG.

### <a id="faster"></a> Faster

> Суть: ускорить свою реализацию, чтобы в релизе она успевала обработать большой jpeg за меньше, чем 8 секунд

Используйте `perf record` и `perf report` для вашего бинаря в релизной сборке
(без ASAN, без TSAN и с `-DCMAKE_BUILD_TYPE=RelWithDebInfo`).

Идеи для оптимизаций:

* Деление на одно и то же число можно заменить на умножение на обратное
* Делать reserve перед push_back
* Оптимизация дерева Хаффмана
* Исправить хранение матриц

Любые хаки в рамках разумного разрешены (никакой глобальной памяти, пожалуйста).

### <a id="progressive"></a> Progressive

> Суть: продвинутая версия JPEG декодера, которая позволит читать любые жпеги мира.

Не обсуждается на семинарах. Здесь вам придется разобраться со [спецификацией JPEG](http://www.w3.org/Graphics/JPEG/itu-t81.pdf).

### <a id="fuzz"></a> Fuzz

> Суть: проверить, что ваше решение не содержит известных багов с помощью fuzzing-тестирования.

Таргеты для fuzzing называются `fuzz_huffman`, `fuzz_fft` и `fuzz_jpeg`. Обратите внимание, для локальной отладки вам потребуется clang (apple clang не подойдет). На Ubuntu его можно установить с помощью [скрипта](https://apt.llvm.org/), на OS X выполните `brew install llvm`.

Чтобы собрать таргеты не дефолтным компилятором, создайте отдельную сборочную директорию и передайте `cmake` аргументы `-DCMAKE_C_COMPILER=PATH_TO_YOUR_CLANG -DCMAKE_CXX_COMPILER=PATH_TO_YOUR_CLANG++`.

На Ubuntu, как правило, достаточно в качестве пути указать `clang-XX` / `clang++-XX`, где XX - версия. На OS X путь, куда установился LLVM, узнайте через `brew --prefix llvm`, к нему обычно нужно добавить `llvm/bin/clang` / `llvm/bin/clang++` соответственно. Проверьте, что компилятор в выводе `cmake` тот, который вы ожидаете.

#### Запуск `fuzz_jpeg` c корпусом

Чтобы фаззинг с большей вероятностью нашел баги в вашем коде, будем запускать его с корпусом. В качестве стартового корпуса будем использовать изображения из [tests](./tests). Скопируйте куда-нибудь эту директорию и передайте путь к копии в аргументах командной строки:

```
./fuzz_jpeg path_to_copied_tests_directory
```

Копировать нужно, так как фаззер может добавлять новые входы в корпус и записывать их в переданный каталог.

После запуска последите за процессом первые несколько минут. Когда фаззер перестанет находить ошибки быстро, оставьте его поработать на несколько часов, например, на ночь.

Если ваше решение упало на каком-то входе, можно запустить на нем еще раз (например, с дебаггером) - передайте путь к файлу в аргументе командной строки вместо каталога.

**Важно!** При тестировании на сервере будет действовать следующее правило: если нашелся вход, на котором упало хотя бы одно решение, этот вход добавляется в корпус и на нем проверяются все остальные решения. Таким образом, локальное тестирование не может полностью гарантировать, что вы пройдете тестирование на сервере, однако длительные прогоны фаззера повышают вероятность этого.

## Материалы

* [Wikipedia](https://en.wikipedia.org/wiki/JPEG), русскую версию читать не стоит.
* [Пошаговый разбор с Хабра](https://habrahabr.ru/post/102521/).
* [JPEG-snoop](https://www.impulseadventure.com/photo/jpeg-snoop.html), утилита для дебага,
  без проблем запускается под wine (Ubuntu) или CrossOver (OS X), показывает подробную информацию 
  про JPEG файл. На этом же сайте много полезных статей про JPEG.
* [Спецификация JPEG](http://www.w3.org/Graphics/JPEG/itu-t81.pdf), понадобится для progressive части.
* [Дополнительный пост для любознательных](https://habrahabr.ru/post/206264/).
* [Презентация](JPEG_Decoder.pdf)

## Инфраструктура

- В этом задании вам разрешено менять `CMakeLists.txt`, а значит вы можете добавлять свои файлы с исходниками. Напомним, что если вы добавляете `.cpp`, нужно указать его в списке исходников библиотеки в [CMakeLists.txt](./CMakeLists.txt).

- Для вашего удобства мы подключили библиотеку для логирования `glog`, ниже вы найдете краткий туториал по ней, больше -- в официальной документации.

- В тестах есть возможность записать на диск результаты работы вашего декодера в формате `png`. Чтобы ее включить, пропишите в CMakeLists.txt строку

```
target_compile_definitions(test_baseline PUBLIC HSE_ARTIFACTS_DIR="YOUR_PATH")
```

где `YOUR_PATH` --- путь к директории, в которую будут записаны артефакты. Директория должна существовать. Можно либо указать абсолютный путь (не используйте символ `~`, `fopen` не умеет его интерпретировать), либо указать относительный, тогда он будет вычисляться относительно директории, в которой вы запускаете `test_baseline`.

## Как не страдать при отладке

В проект подключена библиотека логирования и валидации [glog](http://rpg.ifi.uzh.ch/docs/glog.html).
Используйте ее вместо стандартного потока вывода. Что из этой библиотеки может пригодиться вам:

- Разный уровень логирования:

```cpp
DLOG(INFO) << "Preparing coffee";
DLOG(ERROR) << "Oh, our ship is about to blow up!";
```

- Логирование сообщения только при выполнении какого-то предиката:

```cpp
DLOG_IF(INFO, errors > 10) << "Well, we should stop now, I guess";
```

- Логирование не каждого события, а каждых N событий:

```cpp
DLOG_EVERY_N(INFO, 10) << "Got the " << google::COUNTER << "th error";
```

- Валидация инвариантов:

```cpp
CHECK(write(x) == 4) << "Write failed!";
CHECK_NE(1, 2) << ": The world must be ending!";
CHECK_EQ(std::string("abc")[1], 'b');
```

